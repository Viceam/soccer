### 运行逻辑

循环处理五个机器人

### 限速

5m/s，6rad/s, 2.5m/s-2, 3rad/s-2

### 关键的类

##### world_model_info_

含有

1. CoachInfo_   获取match_mode_
2. AgentID_     正在处理的机器人编号
3. field_info_   场地信息      可以获取球门等位置
4. BallInfo_     足球信息        getGlobalLocation()，getVelocity()函数
5. RobotInfo_   机器人信息    getLocation()，getHead()函数
6. Opponents_  对方机器人信息

##### DPoint

点类

场地大小2200*1400

pointofline()函数  用于获取以球位置点为起点，以指定点为方向作_distance长的线段后得到的点

##### action_cmd_

控制运动

### 函数

##### loopcontrol()

主控制函数，首先获取当前比赛模式，设置match_mode_值，后续会用到此变量

```C++
match_mode_ = world_model_info_.CoachInfo_.MatchMode;  //当前模式
```

查看定义

```C++
enum MatchMode {
                  STOPROBOT  =  0,
    				//开球
                  OUR_KICKOFF = 1,
                  OPP_KICKOFF = 2,
    				//界外球
                  OUR_THROWIN = 3,
                  OPP_THROWIN = 4,
    				//点球
                  OUR_PENALTY = 5,
                  OPP_PENALTY = 6,
    				//球门球
                  OUR_GOALKICK = 7 ,
                  OPP_GOALKICK = 8,
    				//角球
                  OUR_CORNERKICK = 9,
                  OPP_CORNERKICK = 10,
    				//任意球
                  OUR_FREEKICK = 11,
                  OPP_FREEKICK = 12,
    				
                  DROPBALL     = 13,
                  STARTROBOT   = 15,
                  PARKINGROBOT = 25,
                  TEST = 27
                };
```

```C++
///机器人动作
enum Actions
{
    Stucked           =0,
    Penalty           =1,
    CanNotSeeBall     =2,
    SeeNotDribbleBall =3,
    TurnForShoot      =4,                     //射门
    TurnForShoot_Robot=5,			//传给机器人
    AtShootSituation  =6,
    TurnToPass        =7,
    TurnToPass_Robot  =8,
    StaticPass        =9,
    AvoidObs          =10,
    Catch_Positioned  =11,
    Positioned        =12,
    Positioned_Static =13,
    KickCoop          =14,
    KickCoop_turn     =15,
    CatchBall         =16,          	 //抓取球
    CatchBall_slow    =17,
    CircleTest        =18,
    MoveWithBall      =19,  	   //运球
    TeleopJoy         =20,
    No_Action         =21,        	 //不行动
};
```



```C++
  pre_match_mode_ = world_model_info_.CoachInfo_.MatchType;           //! 上一个比赛模式
        robot_pos_  = world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getLocation();//获取位置
        robot_ori_  = world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getHead();//获取朝向，与x轴正向
        ball_pos_   = world_model_info_.BallInfo_[world_model_info_.AgentID_-1].getGlobalLocation();//球位置
        ball_vel_   = world_model_info_.BallInfo_[world_model_info_.AgentID_-1].getVelocity();//球速
```

根据match_mode_执行静止(No_Action)

```C++
if(match_mode_ == STOPROBOT )
        {
            /// 运动参数
            action_cmd_.move_action = No_Action;
            action_cmd_.rotate_acton = No_Action;
        }
/*action_cmd_为控制机器人运动的类*/
```

或调用positioning(), parking(), normalGame()函数

```C++
        /** 机器人在开始之前的跑位. 开始静态传接球的目标点计算*/
        else if(match_mode_ > STOPROBOT && match_mode_ <= DROPBALL)
            positioning();
        
        //泊
        else if(match_mode_ == PARKINGROBOT)
            parking();
		// 机器人正式比赛，进入start之后的机器人状态
        else
        {
            normalGame();
        } 
```

必定调用handleball(), setEthercatCommand(), pubStrategyInfo()函数

##### positioning()

机器人在开始前的跑位;

根据match_mode_，调用OppDefaultReady() 或OurDefaultReady() 调整站位

可自行编写站位策略，应对不同的情况



##### OppDefaultReady()与OurDefaultReady()

己方或对方进行行动前的站位

默认实现:

首先根据机器人编号获取目标点(target), 

```C++
switch(world_model_info_.AgentID_)  // 十分简单的实现，固定的站位，建议动态调整站位，写入staticpass.cpp中
        {                                   // 站位还需要考虑是否犯规，但是现在这个程序没有考虑。
        case 1:
            target = DPoint(-1050.0,0.0);
            break;
        case 2:
            target = ball_pos_.pointofline(robot_pos_,100.0);
            break;
        case 3:
            target = ball_pos_.pointofline(robot_pos_,200.0);
            break;
        case 4:
            target = DPoint(-550.0,200.0);
            break;
        case 5:
            target = DPoint(-550.0,-200.0);
            break;
        }
/*机器人编号从一到五，守门员为1*/
```

然后调用函数判断机器人距离及角度是否合适

```C++
if(target.distance(ball_pos_) < 300 && 							         	    !world_model_info_.field_info_.isOurPenalty(target))
 	target = ball_pos_.pointofline(target,320.0);
//
if(move2target(target, robot_pos_)) //移动函数, 默认参数调用
    move2ori(br.angle().radian_, robot_ori_.radian_);
```

其中函数pointofline(): 

```C++
template<typename _Tp> template<typename _Tp2>inline DPoint_<_Tp> DPoint_<_Tp>::pointofline(const DPoint_<_Tp2>& pt, const double & _distance) const
{
    Angle theta =atan2(double(pt.y_-y_), double(pt.x_-x_));
    return DPoint_<_Tp>(_Tp(x_+cos(theta.radian_)*_distance),_Tp(y_+sin(theta.radian_)*_distance));
}
```

用于获取以该点为起点，以指定点为方向作_distance长的线段后得到的点。



调整好后静止

```C++
action_cmd_.move_action = Positioned_Static;
        action_cmd_.rotate_acton = Positioned_Static;
        action_cmd_.rotate_mode = 0;
```



##### parking()

首先获取目标点

```C++
static double parking_y = -680.0;
        cout<<"PARKINGROBOT"<<endl;
        DPoint parking_target;
        float tar_ori = SINGLEPI_CONSTANT / 2.0;//  PI / 2
        //确定停止点
        parking_target.x_= FIELD_XLINE7 + 150.0 * world_model_info_.AgentID_;
```

然后调用函数判断距离与角度



##### handleball()

是否控球

控制(bool)action_cmd_.handle_enable



##### isNearestRobot() 

判断是否为距球最近的机器人

```C++
float distance_min = 2000.0;
        float distance = distance_min;
        int robot_id = -1;

        for(int i=1;i < OUR_TEAM;i++)     // 排除守门员
            if(world_model_info_.RobotInfo_[i].isValid())
            {
                distance = ball_pos_.distance(world_model_info_.RobotInfo_[i].getLocation());
                if(distance < distance_min)
                {
                    distance_min=distance;
                    robot_id = i;
                }
            }
        if(robot_id+1 == world_model_info_.AgentID_)
            return true;
        else
            return false;
```

遍历，求距离，寻找最近，并判断是否为当前正在处理的机器人

ball_pos_ 球的位置

world_model_info_.RobotInfo_[] 下标从零开始



##### normalGame()

正常比赛阶段函数

首先判断当前机器人是否距球最近，如果是，将isactive设为true;

```C++
isactive =false;
        if(world_model_info_.AgentID_ ! = 1 && isNearestRobot())
        {
            isactive = true;
        }
```

距球最近且不射门

```C++
if(isactive && !shoot_flag)
```

**world_model_info_.field_info_.oppGoal_[GOAL_MIDDLE]为球门中间位置**

```C++
			DPoint b2r = ball_pos_ - robot_pos_; 		/*相对坐标向量*/
            DPoint tmp(200.0,300.0);
            DPoint t2r = tmp - robot_pos_;      /*相对坐标向量*/
            DPoint shoot_line = world_model_info_.field_info_.oppGoal_[GOAL_MIDDLE] - robot_pos_; 	/*射门向量*/
			
		//不运球
            if(last_dribble != world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getDribbleState())
                ROS_INFO("change::");
            last_dribble = world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getDribbleState();
```

去追球

```C++

if(!world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getDribbleState())
            {
                action_cmd_.handle_enable = 1;
                if(move2ori(b2r.angle().radian_,robot_ori_.radian_))
                    move2target(ball_pos_,robot_pos_);
                action_cmd_.move_action = CatchBall;
                action_cmd_.rotate_acton = CatchBall;//拿取球
                action_cmd_.rotate_mode = 0;
            }
```

运球到目标点

```C++
else if(robot_pos_.distance(tmp) > 30.0)
            {
                action_cmd_.move_action = MoveWithBall;
                action_cmd_.rotate_acton = MoveWithBall;//运球
                action_cmd_.rotate_mode = 0;
                if(move2ori(t2r.angle().radian_,robot_ori_.radian_))
                    move2target(tmp,robot_pos_);
            }
```

距目标点tmp<=30.0，射门

```C++
else
            {
                action_cmd_.move_action = TurnForShoot;
                action_cmd_.rotate_acton = TurnForShoot;
                action_cmd_.rotate_mode = 0;          
                move2target(tmp,robot_pos_);
                move2ori(shoot_line.angle().radian_,robot_ori_.radian_);
    
                {
                    //球门上下柱两个角度
                    double up_radian_  = (world_model_info_.field_info_.oppGoal_[GOAL_MIDUPPER] - robot_pos_).angle().radian_;
                    double low_radian_ = (world_model_info_.field_info_.oppGoal_[GOAL_MIDLOWER] - robot_pos_).angle().radian_;
                    if(robot_ori_.radian_ > low_radian_ && robot_ori_.radian_ < up_radian_) //在范围内
                    {
                        action_cmd_.shootPos = RUN/*FLY*/; //平射或吊射     
                        action_cmd_.strength = shoot_line.length() / 100;  //力量计算
                        if(action_cmd_.strength < 3.0)
                            action_cmd_.strength = 3.0;    //保证strength >= 3;
                        shoot_flag = true;         //防止继续去追球
                        std::cout<<"shoot done "<<std::endl;
                    }
                }
            }
		
		//在一定时间内不行动
		else
        {
            action_cmd_.move_action = No_Action;
            action_cmd_.rotate_acton = No_Action;
            if(shoot_flag)
                shoot_count++;
            if(shoot_count > 20)
            {
                shoot_count = 0;
                shoot_flag = false;
            }
        }
```



##### setEthercatCommand()

使用command类控制

```C++
        nubot_common::ActionCmd command;
		//init
        command.move_action  = No_Action;
        command.rotate_acton = No_Action;
        command.rotate_mode  = 0;
        command.maxvel = 0;
        command.maxw   = 0;
        command.target_w   =0;
```

机器人位置信息

```C++
        command.robot_pos.x = world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getLocation().x_;//x左标
        command.robot_pos.y = world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getLocation().y_;//y坐标
        command.robot_vel.x = world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getVelocity().x_;//x速度
        command.robot_vel.y = world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getVelocity().y_;//y速度
        command.robot_ori = world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getHead().radian_;//方向角
        command.robot_w = world_model_info_.RobotInfo_[world_model_info_.AgentID_-1].getW();							//角速度
```

运动参数

```C++
		command.move_action = action_cmd_.move_action;  //移动
        command.rotate_acton = action_cmd_.rotate_acton;  //转向
        command.rotate_mode = action_cmd_.rotate_mode; //转向模式   
        command.target      = action_cmd_.target;               //目标
        command.target_vel  = action_cmd_.target_vel; //速度
        command.target_w    = action_cmd_.target_w;	//角速度
        command.target_ori  = action_cmd_.target_ori;//方向角
        command.maxvel      = action_cmd_.maxvel;    //最大速度
        command.maxw        = action_cmd_.maxw;			//最大角速度
```

防越界

```C++
if(command.maxvel > MAXVEL)
            command.maxvel = MAXVEL;
        if(command.maxw > MAXW)
            command.maxw = MAXW;
        if(fabs(command.target_ori) > 10000.0)
            command.target_ori = 0;
```



```C++
/// 带球及射门选择
        command.handle_enable = action_cmd_.handle_enable;
        command.strength = action_cmd_.strength;
        if(command.strength != 0)
            std::cout<<"passed out"<<command.strength<<std::endl;
        command.shootPos = action_cmd_.shootPos;
          
        /// 传一次后，力量清0,防止多次射门   
        action_cmd_.strength = 0;   
        action_cmd_pub_.publish(command);
```



##### move2target()

移动函数，应确定合理的v-s函数，可运用PID

```C++
    bool move2target(DPoint target, DPoint pos, double distance_thres = 20.0)     // 一个十分简单的实现，可以用PID
    {
        action_cmd_.target.x = target.x_;
        action_cmd_.target.y = target.y_;
        action_cmd_.maxvel = pos.distance(target);  //最大速度
        if(pos.distance(target) > distance_thres)   //允许的误差
            return false;
        else
            return true;
    }
```



##### move2ori()

转动函数，要注意角速度的调节，可利用PID防止出现震荡

```C++
    bool move2ori(double target, double angle, double angle_thres = 8.0 * /*PI/180*/ DEG2RAD)  // 一个十分简单的实现，可以用PID
    {
        action_cmd_.target_ori = target;
        action_cmd_.maxw = fabs(target - angle)*2;    //最大角速度
        if(fabs(target - angle) > angle_thres)        // 容许误差
            return false;
        else
            return true;   
    }
```



### 其他

```C++
#define RUN 1   //平射
#define FLY -1   //吊射
//场地大小2200 * 1400 
```

```basic
我方大禁区
(-1100, 345)
(-875, 345)
(-875, -345)
(-1100, -345)

对方大禁区
(1100, 345)
(875, 345)
(875, -345)
(1100, -345)

我方小禁区
(-1100, 195)
(-1025, 195)
(-1025, -195)
(-1100, -195)

对方小禁区
(1100, 195)
(1025, 195)
(1025, -195)
(1100, -195)

我方罚球点(-600, 0)
对方罚球点(600, 0)
```



### 修改记录

1利用输出调试

```C++
ofstream file("test.sys", ios::app);
```



2根据单个机器人带球不超过3米规则，添加带球超过250cm后传球的代码，传给最近的己方机器人

```C++
//在normalGame中设置抓取球的起始点StartPoint;
//add
static DPoint StartPoint;
//end

if (!world_model_info_.RobotInfo_[world_model_info_.AgentID_ - 1].getDribbleState())
                {
                    action_cmd_.handle_enable = 1;
                    if (move2ori(b2r.angle().radian_, robot_ori_.radian_))
                        move2target(ball_pos_, robot_pos_);
                    action_cmd_.move_action = CatchBall;
                    action_cmd_.rotate_acton = CatchBall;
                    action_cmd_.rotate_mode = 0;
    
                    // add
                    StartPoint = robot_pos_;
                    // end
                }
//StartPoint 的值即为最后一次进入此if的值，为抓取球时机器人位置
```



```C++
//添加
//找到最近的机器人
int findNearestRobot()
        {
            auto min_distance = 2200.0F;
            float distance = min_distance;
            int robot_id = -1;
            int i;
            for (i = 1; i < OUR_TEAM; i++)
            {
                // 排除守门员
                if (world_model_info_.RobotInfo_[i].isValid())
                {
                    distance = ball_pos_.distance(world_model_info_.RobotInfo_[i].getLocation());
                    //排除自己
                    if (i != world_model_info_.AgentID_ - 1 && distance < min_distance)
                    {
                        min_distance = distance;
                        robot_id = i;
                    }
                }
            }
            return i;
        }

//传球函数
void passBall()
        {
            action_cmd_.move_action = TurnForShoot_Robot;
            action_cmd_.rotate_acton = TurnForShoot_Robot;
            action_cmd_.rotate_mode = 0;

            int id = findNearestRobot();
            auto target = world_model_info_.RobotInfo_[id].getLocation();
            auto r2t = robot_pos_ - target;

            if (move2ori(r2t.angle().radian_, robot_ori_.radian_))
            {
                action_cmd_.shootPos = RUN ;
                action_cmd_.strength = target.distance(robot_pos_) / 90;
                if (action_cmd_.strength < 3.0)
                    action_cmd_.strength = 3.0;
                shoot_flag = true;
                std::cout << "shoot done " << std::endl;
            }
        }
```





