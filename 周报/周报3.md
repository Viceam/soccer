### 进攻

选取二号机器人为进攻球员

```cpp
//根据守门员纵坐标获取端点d1，d2，射门目标点在d1，d2范围内
        void pre_for_shoot(DPoint& d1, DPoint& d2)
        {
            auto lot = world_model_info_.RobotInfo_[0].getLocation();
            double m_y = lot.y_;
			
            //系数k
            int k = ((m_y > 0) ? -1 : 1);
            //求d1，d1为上门柱或下门柱
            if(k < 0) d1 = world_model_info_.field_info_.ourGoal_[GOAL_MIDLOWER];
            else d1 = world_model_info_.field_info_.ourGoal_[GOAL_MIDLOWER];
			
            //根据守门员站位(纵坐标)，分情况求d2
            if (fabs(m_y) <= 20) {
                d2 = DPoint(-1100.0, k * 60.0);
            }
            else if (fabs(m_y) < 60) {
                d2 = DPoint(-1100.0, m_y + 120.0 * k);
            }
            else {
                d2 = DPoint(-1100.0, 75.0 * k);
            }
        }
```

将d1, d2的中点mid设为转向目标

shoot_line = mid - robot_pos_

```C++
//射门
						action_cmd_.move_action = TurnForShoot;
                        action_cmd_.rotate_acton = TurnForShoot;
                        action_cmd_.rotate_mode = 0;
						//获取d1，d2
                        DPoint d1, d2;
                        pre_for_shoot(d1, d2);
						
						//中点
                        DPoint mid((d1.x_+d2.x_) / 2.0, (d1.y_ + d2.y_) / 2.0);
                        auto shoot_line = mid - robot_pos_;
                        move2target(tmp, robot_pos_);
                        move2ori(shoot_line.angle().radian_, robot_ori_.radian_);

                        {
                            double low_radian_ = (d1 - robot_pos_).angle().radian_;
                            double up_radian_ = (d2 - robot_pos_).angle().radian_;
                            if(low_radian_ > up_radian_) std::swap(low_radian_, up_radian_);
                            
                            //求出球的运动轨迹方程
                            double t_x = robot_pos_.x_, t_y = robot_pos_.y_;
                            auto k = tan(robot_ori_.radian_);                
                            double b = t_y - k * t_x;
                            //与 x = -1100 的交点
                            double y0 = -1100.0 * k + b;
                            
                            //射门的条件：机器人朝向左，且球越过x = -1100的点在门框内并且与守门员距离足够远，或者射门方向角在范围内
                            //up_radian_与low_radian_也可以用d1，d2纵坐标代替
                            //只用角度判断时，由于low_radian_与up_radian_ 相差很小，move2ori函数不够精准，效果不好，所以加入距离判断
                            //机器人朝向左，防止射反
                            bool b1 = robot_ori_.radian_ / DEG2RAD >= 90.0 || robot_ori_.radian_ / DEG2RAD <= -90.0;
                            
                            //相差66设为可射门
                            if ((y0 <= 105 && y0 >= -105 && fabs(y0 - world_model_info_.RobotInfo_[0].getLocation().y_) >= 66.0) ||
                             (robot_ori_.radian_ / DEG2RAD > low_radian_ / DEG2RAD && robot_ori_.radian_ / DEG2RAD < up_radian_ / DEG2RAD) )
                            {
                                action_cmd_.shootPos = RUN /*FLY*/;
                                action_cmd_.strength = shoot_line.length() / 35;
                                if (action_cmd_.strength < 10.0)
                                    action_cmd_.strength = 10.0;
                                shoot_flag = true;
                                std::cout << "shoot done " << std::endl;
                            }
                        }
```

****

### 守门员

拦下球后的行为没有实现

```cpp
//守门员类
class goalKeeper
        {
        public:
            goalKeeper() : world_(), rb_pos(), rb_ori(), ball_pos() {}
            //重载() 初始化
            void operator()(const World_Model_Info &w, const DPoint &rp, const Angle &ro, const DPoint &bp, const DPoint &bv);
            DPoint position();

        private:
            World_Model_Info world_; //世界模型
            DPoint rb_pos; 				//守门员位置
            Angle rb_ori;					//守门员角度
            DPoint ball_pos;			//球位置
            DPoint ball_v;					//球速
            int getArea();					//判断球所在区域
        };

```



```c++
DPoint NuBotControl::goalKeeper::position()
    {

        DPoint target(-1100, 0);
        //计算球路径

        if (ball_v.x_ < 0 && !world_.RobotInfo_[1].getDribbleState())
        {
            double k = ball_v.y_ / ball_v.x_;
            auto x1 = ball_pos.x_;
            auto y1 = ball_pos.y_;
            double b = y1 - k * x1;
			
            //球进门点
            target = DPoint(-1100.0, -1100.0 * k + b);
        }
        return target;
    }
}
```



```cpp
//在NubotControl类中
void goal_keeper()
        {
            DPoint target = gk.position();
            DPoint t2r = target - robot_pos_;
            action_cmd_.move_action = Positioned;
            action_cmd_.rotate_acton = Positioned;
            action_cmd_.rotate_mode = 0;
            if (move2ori(t2r.angle().radian_, robot_ori_.radian_))
                move2target(target, robot_pos_);

            if (target.distance(robot_pos_) <= 20.0)
            {
                auto b2r = ball_pos_ - robot_pos_;
                move2ori(b2r.angle().radian_, robot_ori_.radian_);
            }
    
			//进攻球员已射出且距离300内，去拦球
            if (!world_model_info_.RobotInfo_[1].getDribbleState() && ball_pos_.distance(robot_pos_) <= 300.0)
            {
                action_cmd_.move_action = CatchBall;
                action_cmd_.rotate_acton = CatchBall;
                action_cmd_.rotate_mode = 0;
                move2target(ball_pos_, robot_pos_);
            }
        }
//截下球之后的行为还没有实现
```



还未使用的分区

```cpp
int NuBotControl::goalKeeper::getArea()
    {
        DPoint shoot_robot = world_.RobotInfo_[1].getLocation();
        double k = ball_pos.y_ / (ball_pos.x_ + 1100.0);
        if (k > 2.6)
            return 4;
        if (k < -2.6)
            return 5;
        DPoint mid(-1100, 0);

        double s = ball_pos.distance(mid);
        if (s < 209)
            return 1;
        if (s < 412)
            return 2;
        if (s < 750)
            return 3;
        return 6;
    }
```

<img src="/home/viceam/图片/2022-04-24 19-22-47 的屏幕截图.png" style="zoom:50%;" />

****


### PID控制

$$
u(k) = K_pe(k)+K_i\sum_{n=0}^{k}{e(n)}+K_d(e(k)-e(k-1))
$$

```C++
//基类
class _pid
        {
        public:
            _pid() : kp(0.0), ki(0.4), kd(0.5) {}
            double getki() {return ki;}
            double getkd() {return kd;}
            virtual double getkp(double err) = 0;
        protected:
            double kp, ki, kd;
        };

		//移动
        class Movepid: public _pid
        {
        public:
            double getkp(double err)
            {
                if(err >= 1500.0) kp = 8.0;
                else if(err >= 1000) kp = 7.5 + (err - 1000) * 0.001;
                else if(err > 500) kp = 5.0 + (err - 500) * 0.005; 
                else kp = 5.0;
                return kp;  
            }
        };

		//转向
        class Rotatepid: public _pid
        {
        public:
            double getkp(double err)
            {
                err *= (180.0 / SINGLEPI_CONSTANT);
                if(err > 120.0) kp = 6.0;
                else if(err > 60.0) kp = 4.5 + (err - 60) * 0.025;
                else if(err > 30.0) kp = 3.0 + (err - 30) * 0.05;
                else kp = 3.0;
                return kp;
            }
        };
```

### 录屏射门信息

![](/home/viceam/图片/2022-04-24 20-14-47 的屏幕截图.png)

射门目标点大约是(-1100, 93)，球射出时守门员大约位于球门中心
