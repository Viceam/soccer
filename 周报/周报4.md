### 运动

##### 较快转向

```C++
//PD控制
bool mv2orif_e1(double target, double angle, double angle_thres = 8.0 * DEG2RAD)
{
    shared_ptr<_pid> rotateControl = make_shared<Rotatepid>();
    static double err;
    static double pre_err = fabs(target - angle);
    err = fabs(target - angle);

    //微分d
    double derr = (err - pre_err);

    pre_err = err;
    action_cmd_.target_ori = target;
    action_cmd_.maxw = (rotateControl->getkp(err) + 0.8) * err + (rotateControl->getkd() - 0.1) * derr;
    if (err > angle_thres) 
        return false;
    else
        return true;
}
```

##### 沿x轴负方向运动

由于机器人朝向角正负180度重合，当平行于x轴向负向移动式move2ori等函数判断不准确，在转向函数中加入

```C++
if(fabs(target) / DEG2RAD >= 173.0)
{
    target = fabs(target);
    angle = fabs(angle);
}
```



### 守门员

区域

```C++
int NuBotControl::goalKeeper::getArea()
{
    DPoint shoot_robot = world_.RobotInfo_[1].getLocation();
    //bool _b = world_.field_info_.isOurGoal(ball_pos);
    double k = ball_pos.y_ / (ball_pos.x_ + 1100.0);
    //小禁区角点的射门划分到区域4或5效果较好
    if (k > 2.5)
        return 4;
    if (k < -2.5)
        return 5;
    DPoint mid(-1100, 0);

    double s = ball_pos.distance(mid);
    if (s < 209)
        return 1;
    if (s < 412)
        return 2;
    if (s < 750)
        return 3;
    return 6;
}
```

分区防守策略

```C++
//求角平分线斜率
inline double divk(double k1, double k2)
{
    return ((k1 * k2 - 1 + sqrt((1 - k1 * k2) * (1 - k1 * k2) + (k1 + k2) * (k1 + k2))) / (k1 + k2));
}

//角平分线站位
DPoint NuBotControl::goalKeeper::bisector()
{
    //球与门柱上下连线斜率
    auto up_k = (ball_pos.y_ - 120) / (ball_pos.x_ + 1100.0);
    auto down_k = (ball_pos.y_ + 120) / (ball_pos.x_ + 1100.0);

    //角平分线斜率
    auto k = divk(up_k, down_k);
    //确保是内角平分线
    k = ((ball_pos.y_ > 0) ? fabs(k) : -fabs(k));
    //角平分线与 x = -1075 交点
    return DPoint(-1075.0, -k * 1075 + ball_pos.y_ - k * ball_pos.x_);
}

//获取目标点
DPoint NuBotControl::goalKeeper::position()
{
    auto num = getArea();
    file<<"num = "<<num<<endl;
    //4，5区射门角度大，容易封住射球路径
    if (num == 4)
        return DPoint(-1075, 120);
    if (num == 5)
        return DPoint(-1075, -120);
    //6区威胁很小
    if (num == 6)
        return DPoint(-1075, 0);

    //3区采用角平分线站位
    if (num == 3)
        return this->bisector();
	//2区
    if (num == 2)
    {
        //如果球向球门移动，守门员垂直运动到球的路径上
        //很长的时间用于转向，还要改进转向函数
        if (ball_v.x_ < 0)
        {
            double k1 = ball_v.y_ / ball_v.x_;
            double b1 = ball_pos.y_ - k1 * ball_pos.x_;
            double k2 = -1.0 / k1;
            double b2 = rb_pos.y_ - k2 * rb_pos.x_;
            //过守门员所在点向运动轨迹作垂线的垂足
            return DPoint((b2 - b1) / (k1 - k2), (k1 * b2 - k2 * b1) / (k1 - k2));
        }
        //否则采用角平分线站位//
        else
            return this->bisector();
    }

    //num == 1 的情况
    //  ...  //
    return DPoint(-1075, 0);
}
```

如果守门员根据射门球员朝向运动，很容易被假动作绕开，不理会射门者的转向很难防守在 y = 0线附近的射门。守门员应与其他球员的合作防守很重要。

还没有加入后退与横向移动动作。

### 射门

在两门柱间循环转向，满足条件后射门

射门点纵坐标在(-120, 120)间时容易射进

```C++
action_cmd_.move_action = TurnForShoot;
action_cmd_.rotate_acton = TurnForShoot;
action_cmd_.rotate_mode = 0;

static DPoint shoot_target = pre_for_shoot();
// DPoint mid((d1.x_ + d2.x_) / 2.0, (d1.y_ + d2.y_) / 2.0);
// auto shoot_line = mid - robot_pos_;
auto shoot_line = shoot_target - robot_pos_;
move2target(tmp, robot_pos_);
//快速转向函数
mv2orif_e1(shoot_line.angle().radian_, robot_ori_.radian_);

//求出球的运动轨迹方程
double t_x = robot_pos_.x_, t_y = robot_pos_.y_;
auto k = tan(robot_ori_.radian_);
double b = t_y - k * t_x;
//与 x = -1100 的交点
double y0 = -1100.0 * k + b;
//判断朝向
bool b1 = robot_ori_.radian_ / DEG2RAD >= 90.0 || robot_ori_.radian_ / DEG2RAD <= -90.0;
//射门条件，绕开守门员足够距离
if (b1 && y0 <= 95 && y0 >= -95 && fabs(y0 - world_model_info_.RobotInfo_[0].getLocation().y_) >= 66.0)
{
    action_cmd_.shootPos = RUN ;
    action_cmd_.strength = shoot_line.length() / 15;
    if (action_cmd_.strength < 10.0)
        action_cmd_.strength = 10.0;
    shoot_flag = true;
    std::cout << "shoot done " << std::endl;
}
//接近边界
if(fabs(shoot_line.angle().radian_ - robot_ori_.radian_) <= 0.10)
{
    //转向另一个门柱位置
    if(shoot_target == world_model_info_.field_info_.ourGoal_[GOAL_UPPER])
        shoot_target = world_model_info_.field_info_.ourGoal_[GOAL_LOWER];
    else shoot_target = world_model_info_.field_info_.ourGoal_[GOAL_UPPER];
}
```

pre_for_shoot()

```C++
inline DPoint pre_for_shoot()
{
    if (world_model_info_.RobotInfo_[0].getLocation().y_ > 0)
        return world_model_info_.field_info_.ourGoal_[GOAL_MIDLOWER];
    else
        return world_model_info_.field_info_.ourGoal_[GOAL_MIDLOWER];
}
```

