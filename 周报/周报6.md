### 通信

通过查看传球相关变量的定义与引用修改以下内容:

- pubStrategyInfo()函数中添加要发送的策略信息信息

  ```C++
  void pubStrategyInfo()
          {
              nubot_common::StrategyInfo strategy_info; // 这个消息的定义可以根据个人需要进行修改
              strategy_info.header.stamp = ros::Time::now();
              strategy_info.AgentID = world_model_info_.AgentID_;
              strategy_info.is_dribble = ball_holding_.BallIsHolding;
  
              strategy_info.pass_cmd.pass_id = world_model_info_.pass_ID_;
              strategy_info.pass_cmd.catch_id = world_model_info_.catch_ID_;
              strategy_info.pass_cmd.is_passout = world_model_info_.is_passed_out_;
              strategy_info.pass_cmd.is_valid = world_model_info_.pass_cmds_.isvalid;
              strategy_info.pass_cmd.is_dynamic_pass = world_model_info_.is_dynamic_pass_;
              strategy_info.pass_cmd.is_static_pass = world_model_info_.is_static_pass_;
  
              strategy_info_pub_.publish(strategy_info);
          }
  ```

  - 在loopControl()中调用update;
  
    `world_model_info_.update(ball_holding_.BallIsHolding);`
  
    update 调用set更新pass_state_
  

### 传

##### 传球准备

```C++
DPoint r2b = ball_pos_ - robot_pos_;
if (last_dribble != world_model_info_.RobotInfo_[world_model_info_.AgentID_ - 1].getDribbleState())
    ROS_INFO("change::");
last_dribble = world_model_info_.RobotInfo_[world_model_info_.AgentID_ - 1].getDribbleState();

if (!last_dribble)		//catchball
{
    action_cmd_.handle_enable = 1;
    if (mv2orif_e1(r2b.angle().radian_, robot_ori_.radian_))
        move2target(ball_pos_, robot_pos_);
    action_cmd_.move_action = CatchBall;
    action_cmd_.rotate_acton = CatchBall;
    action_cmd_.rotate_mode = 0;
}

else		// passball
{
    int pass__mode = RUN;
    auto pass_vec_ = world_model_info_.RobotInfo_[1].getLocation() - robot_pos_;

    if (pass_vec_.length() > 650) //dis > 650 fly
        pass__mode = FLY;

    shoot_flag = m_plan_.PassBall_Action(2, pass__mode);
}
```

##### 传球动作

```C++
bool Plan::PassBall_Action(int catch_ID, int pass_mode_)
{
    world_model_->pass_ID_ = world_model_->AgentID_;
    world_model_->catch_ID_ = catch_ID;
    world_model_->catch_pt_ = world_model_->RobotInfo_[catch_ID - 1].getLocation();
    bool shoot_flag = false;
    bool kick_off = false;
    
    world_model_->is_passed_out_ = true;
    world_model_->pass_cmds_.isvalid = true;
    
    DPoint pass_target_ = world_model_->RobotInfo_[catch_ID - 1].getLocation() - robot_pos_;
    if (m_behaviour_.move2orif(pass_target_.angle().radian_, robot_ori_.radian_, 0.087))
    {
        world_model_->is_static_pass_ = 1; 
        action->shootPos = pass_mode_;

        if (pass_mode_ == -1) // FLY
            action->strength = sqrt((pass_target_.length() / 100.0 - 2.0) * 9.8);
        else
        {
            action->strength = action->strength = pass_target_.length() / 30;
            if (action->strength < 5.0)
                action->strength = 5.0;
        }
        shoot_flag = true;
        std::cout << "pass out" << std::endl;
        kick_off = true;
    }
    return shoot_flag;
}

```



### 接

```cpp
if (world_model_info_.pass_state_.catch_id_ == world_model_info_.AgentID_)
{
    //收到信号后首先朝向球
    action_cmd_.rotate_acton = CatchBall;
    action_cmd_.move_action = No_Action;
    action_cmd_.rotate_mode = 0;
    m_plan_.m_behaviour_.move2orif(r2b.angle().radian_, robot_ori_.radian_, 0.087);

    DPoint headoffPoint;
    
    //垂直运动到球路径上
    if (ball_vel_.length())
    {
        // action_cmd_.move_action = CatchBall;
        double k1 = ball_vel_.y_ / ball_vel_.x_;
        double b1 = ball_pos_.y_ - k1 * ball_pos_.x_;
        double k2 = -1.0 / k1;
        double b2 = robot_pos_.y_ - k2 * robot_pos_.x_;
        //球路径上的点
        headoffPoint = DPoint((b2 - b1) / (k1 - k2), (k1 * b2 - k2 * b1) / (k1 - k2));
    }

    if ((action_cmd_.move_action = CatchBall) /*解除移动限制*/&& move2target(headoffPoint, robot_pos_))
    {
        //catchball
        if (robot_pos_.distance(ball_pos_) <= 250.0 && !world_model_info_.RobotInfo_[world_model_info_.AgentID_ - 1].getDribbleState() && !world_model_info_.RobotInfo_[world_model_info_.pass_state_.pass_id_ - 1].getDribbleState())
        {
            action_cmd_.handle_enable = 1;
            action_cmd_.move_action = CatchBall;
            action_cmd_.rotate_acton = CatchBall;
            action_cmd_.rotate_mode = 0;
            if (mv2orif_e1(r2b.angle().radian_, robot_ori_.radian_))
                move2target(robot_pos_, robot_pos_);
        }
    }

    //   ?
    if (whichopp_dribble() >= 0)
        world_model_info_.pass_state_.reset();
}

/*...其他动作...*/
```

