#### 守门员站位

##### 球在己方大禁区或对方半场

如果球在对方半场，对方的射门容易拦下，且根据规则对方射门无效，守门员站在球门中央

球在己方大禁区，目前将位置设在球门中央

##### 球在我方半场且不在禁区

###### 横坐标

` x_ = 0.25 * ball_pos_.x_ - 875;`

变化范围[-1100, -875]

###### 纵坐标

先求得球与门柱的连线与守门员活动底线x = x_ 的交点`p1(x_, y_up), p2(x_, y_low)`, 

然后求出球到p1的距离s1, 到p2的距离s2, 根据比例获取y_  

` y_ = y_low + s2 / (s1 + s2) * (y_up - y_low);`

```C++
       //获取守门员站位
		DPoint gk_get_target()
        {
            double x_(0.0);
            double y_(0.0);
            auto dis = ball_pos_.distance(robot_pos_);

            // 球在我方大禁区, 守门员站在球门中间
            if (world_model_info_.field_info_.isOurPenalty(ball_pos_))
                return DPoint(world_model_info_.field_info_.ourGoal_[GOAL_MIDDLE]);

            //球在己方半场
            else if (world_model_info_.field_info_.isOurField(ball_pos_))
            {
                //守门员活动的x坐标
                x_ = 0.25 * ball_pos_.x_ - 875;

                //球与上门柱点的连线与 x = x_的交点p1
                auto x1 = world_model_info_.field_info_.ourGoal_[GOAL_MIDUPPER].x_;
                auto y1 = world_model_info_.field_info_.ourGoal_[GOAL_MIDUPPER].y_;
                double k = (ball_pos_.y_ - y1) / (ball_pos_.x_ - x1);
                double y_up = k * x_ + y1 - k * x1;
                DPoint p1(x_, y_up);

                //球与下门柱点的连线与 x = x_的交点p2
                x1 = world_model_info_.field_info_.ourGoal_[GOAL_MIDLOWER].x_;
                y1 = world_model_info_.field_info_.ourGoal_[GOAL_MIDLOWER].y_;
                k = (ball_pos_.y_ - y1) / (ball_pos_.x_ - x1);
                double y_low = k * x_ + y1 - k * x1;
                DPoint p2(x_, y_low);

                //比例站位
                double s1 = ball_pos_.distance(p1);
                double s2 = ball_pos_.distance(p2);
                y_ = y_low + s2 / (s1 + s2) * (y_up - y_low);
            }

            //球在对方半场 对方进球无效
            else
                return DPoint(world_model_info_.field_info_.ourGoal_[GOAL_MIDDLE]);
            return DPoint(x_, y_);
        }

        
```

****

#### 守门员动作控制

球在小禁区或距离守门员足够近，守门员抢球

否则根据球的位置调整站位

观看比赛发现守门员拦下球后经常会出现僵持局面，需由裁判移动球与机器人位置。目前空缺守门员控球时的

```C++
 void goal_keeper()
        {
            DPoint target;
            DPoint b2r = ball_pos_ - robot_pos_;
            //球在小禁区，去拦球
            if (world_model_info_.field_info_.isOurGoal(ball_pos_))
            {
                if (!world_model_info_.RobotInfo_[0].getDribbleState())
                {
                    action_cmd_.handle_enable = 1;
                    if (move2ori(b2r.angle().radian_, robot_ori_.radian_))
                        move2target(ball_pos_, robot_pos_);
                    action_cmd_.move_action = CatchBall;
                    action_cmd_.rotate_acton = CatchBall;
                    action_cmd_.rotate_mode = 0;
                }
                else
                {
                    //传球等
                    /*...*/
                }
            }
            //去抢球
            else if (ball_pos_.distance(robot_pos_) <= 125.0)
            {
                if (!world_model_info_.RobotInfo_[0].getDribbleState())
                {
                    //file << "dis po" << endl;
                    action_cmd_.handle_enable = 1;
                    if (move2ori(b2r.angle().radian_, robot_ori_.radian_))
                        move2target(ball_pos_, robot_pos_);
                    action_cmd_.move_action = CatchBall;
                    action_cmd_.rotate_acton = CatchBall;
                    action_cmd_.rotate_mode = 0;
                }
                else
                {
                    //传球等
                    /*...*/
                }
            }
            //调整站位
            else
            {
                target = gk_get_target();
                DPoint t2r = target - robot_pos_;
                action_cmd_.move_action = Positioned;
                action_cmd_.rotate_acton = Positioned;
                action_cmd_.rotate_mode = 0;
                if (move2ori(t2r.angle().radian_, robot_ori_.radian_))
                    move2target(target, robot_pos_);
            }
        }
```

